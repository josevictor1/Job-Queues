(require '[clojure.data.json :as json])
json/write-str { :key1 "val1" :key2 "val2" })
(json/write-str { :key1 "val1" :key2 "val2" })
json/read-str (slurp "/tmp/test.json"))
(spit "/tmp/test.json" (json/write-str {:key1 "val1" :key2 "val2"}))
(def teste (json/read-str (slurp "/tmp/test.json")))
(teste)
(json/read-str (slurp "/tmp/test.json"))
(def teste (json/read-str (slurp "/tmp/test.json")))
(print teste)
(seq teste)
(require '[theproject.core :as theproject] :reload)
(defn read-json)
(json/read-str (slurp "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json"))
(read-json[])
(read-json)
(json/read-str (slurp "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json"))
(defn teste [] ((json/read-str (slurp "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json"))))
(teste)
(require '[theproject.core :as theproject] :reload)
(read-json)
(require '[theproject.core :as theproject] :reload)
(read-json)
(require '[theproject.core :as theproject] :reload)
(def archivepath "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json")
(defn read-json [path] (
   (json/read-str (slurp path))
))
(defn read-json [path] (
   (json/read-str (slurp path))
))
defn read-archive [path] (slurp path))
(defn read-archive [path] (slurp path))
(defn readjson [path] (json/read-str (read-archive path)))
(require '[clojure.data.json :as json])
(defn read-archive [path] (slurp path))
(defn readjson [path] (json/read-str (read-archive path)))
(defn read-json [path] (json/read-str (read-archive path)))
(require '[clojure.data.json :as json])
(require '[theproject.core :as theproject] :reload)
(read-json archivepath)
(require '[theproject.core :as theproject] :reload)
(read-json archivepath)
lein dep
exit()
(require '[theproject.core :as therproject] :reload)
(map #(cheshire/parse-string % true)
     (line-seq (clojure.java.io/reader "data/json_data")))
(map #(parse-string % true)
     (line-seq (clojure.java.io/reader "data/json_data")))
(map #(parse-string % true)
     (line-seq (clojure.java.io/reader "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json")))
(map #(parse-string % true)
     (line-seq (clojure.java.io/reader "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json")))
(map #(parse-string % true)
     (line-seq (clojure.java.io/reader "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input")))
(map #(parse-string % true)
     (line-seq (clojure.java.io/reader "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/jason_data.json")))
(def read-json-data (parse-string (slurp "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/jason_data.json") true))
(read-json-data)
(generate-string {:foo "bar" :baz {:eggplant [1 2 3]}} {:pretty true})
(parse-string (slurp "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/jason_data.json"))
(require '[theproject.core :as therproject] :reload)
(parse-string (slurp "/Users/josevictorpereiracosta/Documents/secret/jobqueue/resource/sample-input.json"))
(require '[theproject.core :as therproject] :reload)
(teste)
(teste archivepath)
(require '[theproject.core :as therproject] :reload)
(teste archivepath)
(require '[theproject.core :as therproject] :reload)
(doc concat)
(require '[theproject.core :as therproject] :reload)
(docs or)
(doc or)
(def teste nil)
(if (teste) true false)
(if (= teste nil) true false)
(let (out []) (for [i (range 10)] (println i)))
(let [out []] (for [i (range 10)] (conj out i)))
(let [out []] (for [i (range 10)] (cons out i)))
(let [out []] (for [i (range 10)] (conj out i)))
(let [out []] ((loop [x 10]))
  (when (> x 1)
    (println x)
    (recur (- x 2))))
(< 1 2)
(let [out ()] (loop [i  0]
  (when (< i 10) (conj out i) (recur (+ i 1)))))
(print datareceived)
(vec '(1 2 3 4 5))
(vec datareceived)
(defn mountjob_assigned [job agent] ({:job_assigned {:job_id (:id (:new_job job)) :agent_id (:id (:new_agent agent))}}))
(def teste [1 2 3 4 5 6 7])
(some #{1} teste)
(def skill :primary)
(def teste {:primary 1})
(skill teste)
exit()
